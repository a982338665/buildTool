
# 来源
>https://zhuanlan.zhihu.com/p/137368446


## 1.数据库瓶颈

    1.根本原因：数据库连接不够用
    2.分类：
        1.IO瓶颈
            1.磁盘IO：热点数据太多，数据库本地缓存不够用，就回去查询数据文件，产生大量磁盘io，降低查询速度 【分库/垂直分表】
            2.网络IO：网络IO瓶颈，请求的数据太多，网络带宽不够 -> 分库。
        2.CPU瓶颈
            1.sql慢查询：如SQL中包含join，group by，order by，非索引字段条件查询等，增加CPU运算的操作 -> SQL优化，建立合适的索引，在业务Service层进行业务计算。
            2.单表数据量太大，查询时扫描的行太多，SQL效率低，CPU率先出现瓶颈 -> 水平分表。

## 2.分库分表
    
    1.水平分库 -> 一库拆多库（按数据规则）
        1.以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。
        2.结果：
            ・ 每个库表结构相同
            ・ 每个库数据不同，无交集
            ・ 并集为全量数据
        3.场景：系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。
          分析：库多了，io和cpu的压力自然可以成倍缓解。
        4.结论：并发量高的时候无论怎么分表，都无法解决网络io问题，分表只是更细粒度的去提高磁盘io效率，以及单表数据量大的问题
    2.水平分表 -> 一表拆多表（按数据规则）
        1.以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中
        2.结果：
            ・表结构相同，表名不同
            ・表中数据是按规则分的，所以不同
            ・多表并集为全量数据
        3.场景：单表数据量太大，影响sql效率，加重cpu负担，成为瓶颈    
          分析：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中
    3.垂直分库 -> 多表分多库（按业务规则）微服务一个服务一个库
        1.以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。
        2.结果：
            ・库不同，表不同，数据不同
            ・所有库的并集是全量数据；
        3.场景：系统绝对并发量上来了，并且可以抽象出单独的业务模块。
        4.分析：到这一步，基本上就可以服务化了。例如，随着业务的发展一些公用的配置表、字典表等越来越多，这时可以将这些表拆到单独的库中，甚至可以服务化。
                再有，随着业务的发展孵化出了一套业务模式，这时可以将相关的表拆到单独的库中，甚至可以服务化
    4.垂直分表 -> 一个表拆为主表+拓展表
        1.以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。
        2.结果：
            ・每个表的结构都不一样；
            ・每个表的数据也不一样，一般来说，每个表的字段至少有一列交集，一般是主键，用于关联数据；
            ・所有表的并集是全量数据；
        3.场景：系统绝对并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据库缓存的数据行减少，
                查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈。
          分析：可以用列表页和详情页来帮助理解。垂直分表的拆分原则是将热点数据（可能会冗余经常一起查询的数据）放在一起作为主表，非热点数据放在一起作为扩展表。
                这样更多的热点数据就能被缓存下来，进而减少了随机读IO。拆了之后，要想获得全部数据就需要关联两个表来取数据。但记住，千万别用join，因为join不仅会增加CPU负担并且会讲两个表耦合在一起
                （必须在一个数据库实例上）。关联数据，应该在业务Service层做文章，分别获取主表和扩展表数据然后用关联字段关联得到全部数据。

## 3.分库分表工具

    1.sharding-sphere：jar，前身是sharding-jdbc；
    2.TDDL：jar，Taobao Distribute Data Layer；
    3.Mycat：中间件。    
    
## 4.分库分表规则
    
    根据容量（当前容量和增长量）评估分库或分表个数 -> 选key（均匀）-> 分表规则（hash或range等）-> 执行（一般双写）-> 扩容问题（尽量减少数据的移动）。
    
## 5.分库分表问题
    
    

