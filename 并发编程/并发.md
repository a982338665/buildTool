
#参考博客：https://blog.csdn.net/yusimiao/article/details/105378311?utm_medium=distribute.pc_feed.none-task-blog-alirecmd-4.nonecase&depth_1-utm_source=distribute.pc_feed.none-task-blog-alirecmd-4.nonecase&request_id=
#https://github.com/FraserYu/learnings

**1.并发编程：**
    
    1.充分利用 CPU 和 I/O
    
**2.cpu密集型程序：**
    
    1.计算的比例占多数
    2.例如：
        要计算 1+2+....100亿 的总和，很明显，这就是一个 CPU 密集型程序
    3.单核cpu处理cpu密集型程序分析：
        1.单核cpu，创建4个线程分段计算总和
            thread1:1-25亿加和
            thread2:25-50亿加和
            thread3:50-75亿加和
            thread4:75-100亿加和
        2.由于是单核：
            多线程：所以所有线程都会等待CPU时间片，所以总时间 = 执行时间+切换时间 
            单线程：总时间 = 执行时间（无cpu切换） 
        3.所以：单核情况下，多线程耗时 > 单线程耗时
    4.4核cpu处理cpu密集型程序分析：
        1.前置知识：在多核操作系统中，java多线程不能被指定到具体cpu上，而是由操作系统自动分配
            1.uri:https://blog.csdn.net/a1s2d3q/article/details/50403374
            2.分析：CPU是为了迎合操作系统的多线程从而提高系统的计算效率.但是具体分配任务到各个内核中去执行的并非JAVA与JVM而是操作系统.
                    也就是说,你所执行的多线程,可能会被分配到同一个CPU内核中运行.也可能分配到不同的cpu中运行.如果可以控制CPU的分配,那也应该是操作系统的api才能实现的了
            3.一个java程序代表一个进程，这个进程中会有多个线程被创建，启动。而线程的实现方式如下：
                1.使用内核线程实现：
                    内核线程Kernel Thread：直接由操作系统内核支持的线程，这种线程由内核类完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。
                    轻量级进程Light Weight Process：每个轻量级进程都由一个内核线程支持。
                    局限性：各种进程操作都需要进行系统调用(系统调用代价相对较高，需要在用户态和内核态中来回切换)；轻量级进程要消耗一定的内核资源，一次一个系统支持轻量级进程的数量是有限的。
                2.使用用户线程实现：
                    用户线程：完全建立在用户空间的线程库上，系统内核不能直接感知到线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，
                              不需要内核的帮助。所有的线程操作都需要用户程序自己处理。
                    混合实现：
                    将内核线程和用户线程一起使用的方式。操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁。
            4.Sun JDK，它的Windows版和Linux版都是使用一对一的线程模型来实现的，一条Java线程映射到一条轻量级进程之中。
            5.总结：Sun JDK，它的Windows版和Linux版都是使用一对一的线程模型来实现的，一条Java线程映射到一条轻量级进程之中。
        2.由于是4核：每个线程都有 CPU 来运行，并不会发生等待 CPU 时间片的情况，也没有线程切换的开销。理论情况来看效率提升了 4 倍
        3.总结：所以，如果是多核CPU 处理 CPU 密集型程序，我们完全可以最大化的利用 CPU 核心数，应用并发编程来提高效率
        
**3.IO密集型程序：**
    
    1.广义：与 CPU 密集型程序相对，一个完整请求，CPU运算操作完成之后还有很多 I/O 操作要做，也就是说 I/O 操作占比很大部分
    2.在进行 I/O 操作时，CPU是空闲状态，所以我们要最大化的利用 CPU，不能让其是空闲状态
    3.单核cpu处理IO密集型程序：
              
    
                     
        
              

